<html><head><link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Comfortaa|Raleway|Ubuntu' /><link rel='stylesheet' type='text/css' href='default.css' /><script type='text/javascript' src='default.js'></script><title>numcl</title></head><body><div class="page-header"><div class="title"><h1>numcl</h1></div><div class="table-of-contents"><h1>Index</h1><ol><li><a href="#" data-node=""><span class="directory"></span></a><ol><li><a href="#README.org" data-node="README.org"><span class="file">README</span><span class="extension">org</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/README.org">[edit on web]</a></a></li></ol></li><li><a href="#doc" data-node="doc"><span class="directory">doc</span></a><ol><li><a href="#doc/DETAILS.org" data-node="doc/DETAILS.org"><span class="file">DETAILS</span><span class="extension">org</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/doc/DETAILS.org">[edit on web]</a></a></li></ol></li><li><a href="#src" data-node="src"><span class="directory">src</span></a><ol><li><a href="#src/0package.lisp" data-node="src/0package.lisp"><span class="file">0package</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/0package.lisp">[edit on web]</a></a></li><li><a href="#src/1constantfolded.lisp" data-node="src/1constantfolded.lisp"><span class="file">1constantfolded</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/1constantfolded.lisp">[edit on web]</a></a></li><li><a href="#src/2alias.lisp" data-node="src/2alias.lisp"><span class="file">2alias</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/2alias.lisp">[edit on web]</a></a></li><li><a href="#src/2aref.lisp" data-node="src/2aref.lisp"><span class="file">2aref</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/2aref.lisp">[edit on web]</a></a></li><li><a href="#src/2typeinfer.lisp" data-node="src/2typeinfer.lisp"><span class="file">2typeinfer</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/2typeinfer.lisp">[edit on web]</a></a></li><li><a href="#src/3arange.lisp" data-node="src/3arange.lisp"><span class="file">3arange</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/3arange.lisp">[edit on web]</a></a></li><li><a href="#src/3array.lisp" data-node="src/3array.lisp"><span class="file">3array</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/3array.lisp">[edit on web]</a></a></li><li><a href="#src/3copy.lisp" data-node="src/3copy.lisp"><span class="file">3copy</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/3copy.lisp">[edit on web]</a></a></li><li><a href="#src/3zeros.lisp" data-node="src/3zeros.lisp"><span class="file">3zeros</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/3zeros.lisp">[edit on web]</a></a></li><li><a href="#src/4concatenate.lisp" data-node="src/4concatenate.lisp"><span class="file">4concatenate</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/4concatenate.lisp">[edit on web]</a></a></li><li><a href="#src/4split.lisp" data-node="src/4split.lisp"><span class="file">4split</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/4split.lisp">[edit on web]</a></a></li><li><a href="#src/5numeric.lisp" data-node="src/5numeric.lisp"><span class="file">5numeric</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/5numeric.lisp">[edit on web]</a></a></li><li><a href="#src/5random.lisp" data-node="src/5random.lisp"><span class="file">5random</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/5random.lisp">[edit on web]</a></a></li><li><a href="#src/5reduce.lisp" data-node="src/5reduce.lisp"><span class="file">5reduce</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/5reduce.lisp">[edit on web]</a></a></li><li><a href="#src/5where.lisp" data-node="src/5where.lisp"><span class="file">5where</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/5where.lisp">[edit on web]</a></a></li><li><a href="#src/6linear-algebra.lisp" data-node="src/6linear-algebra.lisp"><span class="file">6linear-algebra</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/6linear-algebra.lisp">[edit on web]</a></a></li><li><a href="#src/8linear-algebra2.lisp" data-node="src/8linear-algebra2.lisp"><span class="file">8linear-algebra2</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/8linear-algebra2.lisp">[edit on web]</a></a></li></ol></li></ol></div></div><div class="main"><h1 id=""><span class="directory"></span></h1><h2 id="README.org"><span class="file">README</span><span class="extension">org</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/README.org">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><div class="static-file"><div class="docstring"><h1 id="numcl">Numcl <a href="https://travis-ci.org/numcl/numcl"><img src="https://travis-ci.org/numcl/numcl.svg" /></a></h1>
<p>This is a Numpy clone in Common Lisp. At the moment the library is written in pure Common Lisp, focusing more on correctness and usefulness, not speed. Track the progress at <a href="https://github.com/numcl/numcl/projects/1">https://github.com/numcl/numcl/projects/1</a> .</p>
<p><a href="https://asciinema.org/a/245792"><img src="https://asciinema.org/a/245792.svg" /></a></p>
<h2 id="goals">Goals</h2>
<ul>
<li><strong>Closely follow the numpy API, but still make it lispy.</strong>
<ul>
<li>Delegate the documentation effort to Numpy community.</li>
</ul></li>
<li><strong>Replace the Common Lisp array interface.</strong>
<ul>
<li>We do not deviate from the traditional symbols/idioms in Common Lisp unless necessary. Therefore we provide symbols that conflicts the Common Lisp symbol. Math functions become aliases to the original CL functions when the inputs are not arrays.</li>
<li>See <a href="./DETAILS.org#packages">./DETAILS.org#packages</a> .</li>
</ul></li>
</ul>
<h2 id="featurescontracts">Features/Contracts</h2>
<ul>
<li>APIs are provided as functions, not macros.
<ul>
<li>It is a design flaw otherwise.</li>
<li>This does not mean the API is functional — we use procedural code.</li>
</ul></li>
<li>Still, zero overhead.
<ul>
<li>The APIs are simply the wrappers over simple functions and designed to be fully inlined.</li>
<li>Optimization will be done on the compiler side, not by macros.</li>
</ul></li>
<li>Operations are type-correct.
<ul>
<li>They always return arrays of the most specific array-element-type. For example,</li>
<li>(zeros 5) returns a bit vector.</li>
<li>(asarray '(1 2 3)) returns an (unsigned-byte 2) vector.</li>
<li>See <a href="./DETAILS.org#types">./DETAILS.org#types</a> .</li>
</ul></li>
<li>NUMCL Arrays are CL arrays.
<ul>
<li>As this library aims to extend Common Lisp (not to replace part of it) in a compatible way, we do not introduce custom structures/classes for representing an array.</li>
<li>See <a href="./DETAILS.org#representation">./DETAILS.org#representation</a> .</li>
</ul></li>
</ul>
<h2 id="examples-documentation">Examples &amp; documentation</h2>
<p><a href="./example.lisp">./example.lisp</a> contains a script that you can explore the functionality already implemented in NUMCL.</p>
<p>See <em>DETAILS.org</em> for the types available in numcl, and object representation.</p>
<h2 id="dependencies">Dependencies</h2>
<p>NUMCL depends on <a href="https://github.com/numcl/constantfold">https://github.com/numcl/constantfold</a> . This library is at least tested on implementation listed below:</p>
<ul>
<li>SBCL 1.4.12 on X86-64 Linux 4.4.0-141-generic (author's environment)</li>
<li>SBCL 1.5.1 on X86-64 Linux 4.4.0-141-generic (author's environment)</li>
<li>CI tested on CCL, ECL.</li>
</ul>
<p>Dependency graph:</p>
<p><img src="./numcl.png" /></p>
<h2 id="author-license-copyright">Author, License, Copyright</h2>
<p>Masataro Asai (guicho2.71828@gmail.com)</p>
<p>Licensed under LGPL v3.</p>
<p>Copyright (c) 2019 IBM Corporation</p>
</div></div></div></div><h1 id="doc"><span class="directory">doc</span></h1><h2 id="doc/DETAILS.org"><span class="file">DETAILS</span><span class="extension">org</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/doc/DETAILS.org">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><div class="static-file"><div class="docstring"><p>In this document, we detail the inner working of NUMCL.</p>
<h1 id="packages">Packages</h1>
<p>NUMCL defines several symbols which have the same name as the corresponding CL symbols. We call them <strong>conflicting symbols</strong>. To avoid the confusion in the code base, we use 3 packages:</p>
<ul>
<li><code>NUMCL.IMPL</code> (internal package) for implementing numcl.</li>
<li><code>NUMCL.EXPORTED</code> (external package), for storing the numcl exported symbols,</li>
<li><code>NUMCL</code> package, that replaces <code>COMMON-LISP</code> package by shadowing-import symbols from <code>NUMCL.EXPORTED</code> on top of <code>COMMON-LISP</code> package.</li>
</ul>
<h1 id="types">Types</h1>
<p>Common Lisp has the following types for numbers.</p>
<div class="sourceCode" id="cb1" data-org-language="lisp"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">number</span> <span class="op">=</span> (<span class="kw">or</span> <span class="kw">complex</span> <span class="kw">real</span>)</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">real</span>   <span class="op">=</span> (<span class="kw">or</span> <span class="kw">float</span> <span class="kw">rational</span>)</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">rational</span> <span class="op">=</span> (<span class="kw">or</span> <span class="kw">ratio</span> <span class="kw">integer</span>)</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">integer</span>  <span class="op">=</span> (<span class="kw">or</span> <span class="kw">fixnum</span> <span class="kw">bignum</span>)</a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">float</span>    <span class="op">=</span> (<span class="kw">or</span> <span class="kw">short-float</span> ... <span class="kw">long-float</span>) (== irrational).</a></code></pre></div>
<p>Common Lisp defines several rules for the type of the values returned by the numerical operations. The detail of the rules are explained in <a href="http://clhs.lisp.se/Body/12_a.htm">CLHS 12.1 Number Concepts</a>.</p>
<p><em>Rational functions</em> behave as <code>rational* -&gt; rational</code>, <code>float* -&gt; float</code>, <code>{rational,float}* -&gt; float</code>. This rule is called <strong>float contagion</strong> rule.</p>
<p>Rational functions do not guarantee <code>integer -&gt; integer</code>, primarily due to <code>/</code> , which returns <code>integer* -&gt; (or ratio integer)</code>.</p>
<p>Irrational functions behaves as <code>rational -&gt; (or rational float)</code>, <code>float -&gt; float</code>: For a certain irrational functions, implementations are allowed to return the exact rational number or its float approximation. Examples are <code>(sin pi) -&gt; 1/2</code>. The behavior depends on the implementation and is called <strong>float substitution rule</strong>.</p>
<p>—</p>
<p>In NUMCL, <code>ratio</code> does not exist due to three reasons: First, CL prohibits <code>ratio</code> to have a denominator 1 (e.g. 3/1), and thus the operations on ratios are not closed. Second, no implementations provide a specialized array for <code>rational</code>. Finally, ratio computation requires an additional simplification phase (e.g. 2/4 -&gt; 1/2) which does not finish in a constant number of operations and is incompatible to SIMD operations.</p>
<p>As a result, <code>ratios</code> are always converted to <code>*numcl-default-float-format*</code>, which is single-float by default. This means that <code>/</code> always returns a float array (except atomic numbers are given).</p>
<p>We also force irrational functions to always return floats, by coercion. (Implementations are allowed to return rationals for certain constants, e.g. (sin pi).)</p>
<p><code>(array bignum)</code> does not exist either. However, when the result of numerical computation causes a fixnum overflow, it signals an error instead of overflowing silently.</p>
<p>For complex arrays, only <code>(complex *-float)</code> exists (for each float type). Both complex integers and complex ratios are converted into floats. This is because CL does not allow rational complex with imagpart 0 (cf. <a href="http://clhs.lisp.se/Body/t_comple.htm">http://clhs.lisp.se/Body/t_comple.htm</a>), thus the numerical operation always coerces the result into reals. This prevents us from having (ARRAY (COMPLEX FIXNUM)).</p>
<h1 id="representation">Representation</h1>
<p>NUMCL arrays are not based on custom classes or structures. They are merely the displaced multidimentional arrays.</p>
<p>The base function for creating a new array is <code>%make-array</code>, but this is not exported in NUMCL. You should use the wrapper functions like <code>ones</code>, <code>zeros</code>, <code>ones-like</code>, <code>arange</code>, <code>linspace</code>, <code>asarray</code> etc. They are always inline-expanded to <code>%make-array</code>, therefore there is no worry about the performance. These functions analyze the input and return the most specialized array for the input, but you can also specify the element type.</p>
<p><code>%make-array</code> instantiates a new flattened array and returns another array displaced to it with the specified shape. The flattened array is returned as the secondary value (as does all wrapper functions).</p>
<p>The justification for this scheme is that some implementations (esp. SBCL) require an indirection for accessing the array element (e.g. through array-header in SBCL) even for a simple multi-dimentional array and thus using a displacing array has essentially no performance penalty over using a simple multi-dimentional array.</p>
<p>We also ensure that the length of the base arrays are the multiples of 8. This ensures that the program can safely iterate over the extended region with a future support for SIMD operations in mind.</p>
</div></div></div></div><h1 id="src"><span class="directory">src</span></h1><h2 id="src/0package.lisp"><span class="file">0package</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/0package.lisp">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defpackage---numcl.exported-keyword"><span class="doctype">defpackage</span><span class="sep1">:</span><span class="name" id="KEYWORD:NUMCL.EXPORTED">numcl.exported</span><span class="package">keyword</span></h3><div class="docstring"><p>External package for storing the exported symbols.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-package---numcl.impl-keyword"><span class="doctype">define-package</span><span class="sep1">:</span><span class="name" id="KEYWORD:NUMCL.IMPL">numcl.impl</span><span class="package">keyword</span></h3><div class="docstring"><p>Internal package for implementing numcl.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-package---numcl-keyword"><span class="doctype">define-package</span><span class="sep1">:</span><span class="name" id="KEYWORD:NUMCL">numcl</span><span class="package">keyword</span></h3><div class="docstring"><p>NUMCL defines several symbols which have the same name as the corresponding CL symbols. We call them <strong>conflicting symbols</strong>. To avoid the confusion in the code base, we use 3 packages: NUMCL.EXPORTED, NUMCL.IMPL, NUMCL.</p>
<p>This package replaces COMMON-LISP package by shadowing-import symbols from NUMCL.EXPORTED on top of COMMON-LISP package.</p>
</div></div></div><h2 id="src/1constantfolded.lisp"><span class="file">1constantfolded</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/1constantfolded.lisp">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><h3 id="define-foldable-version---make-array-,-vector-,-bit-and-,-bit-andc1-,-bit-andc2-,-bit-eqv-,-bit-ior-,-bit-nand-,-bit-nor-,-bit-not-,-bit-orc1-,-bit-orc2-,-bit-xor-,-mapcar-,-cons-,-adjoin-,-append-,-acons-,-pairlis-,-sublis-,-list-,-list*-,-make-list-,-maplist-,-subst-,-subst-if-,-subst-if-not-,-intersection-,-set-difference-,-set-exclusive-or-,-union-,-ldiff-,-make-sequence-,-subseq-,-concatenate-,-map-,-reduce-,-reverse-,-remove-,-remove-duplicates-,-remove-if-,-remove-if-not-,-substitute-,-substitute-if-,-substitute-if-not-,-make-string-,-string-,-string-capitalize-,-string-downcase-,-string-left-trim-,-string-right-trim-,-string-trim-,-string-upcase-common-lisp"><span class="doctype">define-foldable-version</span><span class="sep1">:</span><span class="name define-foldable-version" id="COMMON-LISP:MAKE-ARRAY">make-array</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:VECTOR">vector</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:BIT-AND">bit-and</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:BIT-ANDC1">bit-andc1</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:BIT-ANDC2">bit-andc2</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:BIT-EQV">bit-eqv</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:BIT-IOR">bit-ior</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:BIT-NAND">bit-nand</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:BIT-NOR">bit-nor</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:BIT-NOT">bit-not</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:BIT-ORC1">bit-orc1</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:BIT-ORC2">bit-orc2</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:BIT-XOR">bit-xor</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:MAPCAR">mapcar</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:CONS">cons</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:ADJOIN">adjoin</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:APPEND">append</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:ACONS">acons</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:PAIRLIS">pairlis</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:SUBLIS">sublis</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:LIST">list</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:LIST*">list*</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:MAKE-LIST">make-list</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:MAPLIST">maplist</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:SUBST">subst</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:SUBST-IF">subst-if</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:SUBST-IF-NOT">subst-if-not</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:INTERSECTION">intersection</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:SET-DIFFERENCE">set-difference</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:SET-EXCLUSIVE-OR">set-exclusive-or</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:UNION">union</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:LDIFF">ldiff</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:MAKE-SEQUENCE">make-sequence</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:SUBSEQ">subseq</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:CONCATENATE">concatenate</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:MAP">map</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:REDUCE">reduce</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:REVERSE">reverse</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:REMOVE">remove</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:REMOVE-DUPLICATES">remove-duplicates</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:REMOVE-IF">remove-if</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:REMOVE-IF-NOT">remove-if-not</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:SUBSTITUTE">substitute</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:SUBSTITUTE-IF">substitute-if</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:SUBSTITUTE-IF-NOT">substitute-if-not</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:MAKE-STRING">make-string</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:STRING">string</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:STRING-CAPITALIZE">string-capitalize</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:STRING-DOWNCASE">string-downcase</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:STRING-LEFT-TRIM">string-left-trim</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:STRING-RIGHT-TRIM">string-right-trim</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:STRING-TRIM">string-trim</span><span class="sep2">,</span><span class="name define-foldable-version" id="COMMON-LISP:STRING-UPCASE">string-upcase</span><span class="package">common-lisp</span></h3><div class="docstring missing">(documentation missing)</div></div></div><h2 id="src/2alias.lisp"><span class="file">2alias</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/2alias.lisp">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defun---shape-numcl.exported-array"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:SHAPE">shape</span><span class="package">numcl.exported</span><span class="args lisp">array</span></h3><div class="docstring"><p>If the input is an array, it returns <code>array-dimensions</code>. Otherwise it returns <code>NIL</code>.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---size-numcl.exported-array"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:SIZE">size</span><span class="package">numcl.exported</span><span class="args lisp">array</span></h3><div class="docstring"><p>An alias to <code>array-total-size</code>.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---rank-numcl.exported-array"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:RANK">rank</span><span class="package">numcl.exported</span><span class="args lisp">array</span></h3><div class="docstring"><p>An alias to <code>array-rank</code>.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---dtype-numcl.exported-array"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:DTYPE">dtype</span><span class="package">numcl.exported</span><span class="args lisp">array</span></h3><div class="docstring"><p>An alias to <code>array-element-type</code>.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---length-numcl.exported-array"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:LENGTH">length</span><span class="package">numcl.exported</span><span class="args lisp">array</span></h3><div class="docstring"><p>If the input is an array, it returns the size of the first dimension. Else, it calls <code>cl:length</code>.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---to-simple-array-numcl.exported-array"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:TO-SIMPLE-ARRAY">to-simple-array</span><span class="package">numcl.exported</span><span class="args lisp">array</span></h3><div class="docstring"><p>Given an array, returns its copy as a simple array.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---reshape-numcl.exported-a-shape"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:RESHAPE">reshape</span><span class="package">numcl.exported</span><span class="args lisp">a shape</span></h3><div class="docstring"><p>Reshape the array while sharing the backing 1D array. -1 implies that the axis size is deduced from the other axes. At most one axis is allowed to be -1. T implies that the axis size is preserved. It can be used as many times, but only at the right/leftmost axes.</p>
<p>Example of reshaping (3 8 5):</p>
<p>valid:</p>
<pre><code>(6 -1 10)     = (6 2 10)
(t 2 2 2 t)   = (3 2 2 2 5)
(3 t t)       = (3 8 5)
(2 -1 2 2 t)  = (2 3 2 2 5)
</code></pre>
<p>invalid:</p>
<pre><code>(2 t 2 2 t)
</code></pre>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---flatten-numcl.exported-a"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:FLATTEN">flatten</span><span class="package">numcl.exported</span><span class="args lisp">a</span></h3><div class="docstring"><p>An alias to <code>alexandria:flatten</code>, but also supports numcl arrays (returns a 1D numcl array).</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---squeeze-numcl.exported-a"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:SQUEEZE">squeeze</span><span class="package">numcl.exported</span><span class="args lisp">a</span></h3><div class="docstring"><p>Removes the axis with dimension 1.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---expand-dims-numcl.exported-a-axes"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:EXPAND-DIMS">expand-dims</span><span class="package">numcl.exported</span><span class="args lisp">a axes</span></h3><div class="docstring"><p>Insert 1-dimensional axes in the positions specified by <code>axes</code>. axes: an int or a list of ints.</p>
</div></div></div><h2 id="src/2aref.lisp"><span class="file">2aref</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/2aref.lisp">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defun---aref-numcl.exported-array-&rest-subscripts"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:AREF">aref</span><span class="package">numcl.exported</span><span class="args lisp">array &amp;rest subscripts</span></h3><div class="docstring"><p>An extended <code>aref</code> that accepts ranges as lists, similar to numpy's array access. For a 3D array x,</p>
<ul>
<li>range</li>
</ul>
<pre><code>x[1:5,2,3]   = (aref x &#39;(1 5) 2 3)
x[2,1:5,3]   = (aref x 2 &#39;(1 5) 3)
x[2,1:2:5,3] = (aref x 2 &#39;(1 2 5) 3)
x[2,1:,3]    = (aref x 2 &#39;(1 t) 3)
x[2,:1,3]    = (aref x 2 &#39;(t 1) 3)
x[2,:,3]     = (aref x 2 &#39;(t t) 3)
x[2,:,3]     = (aref x 2    t   3)
</code></pre>
<ul>
<li>insufficient axis</li>
</ul>
<div class="sourceCode" id="cb2"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb2-1" title="1">(<span class="kw">aref</span> x &#39;(<span class="dv">1</span> <span class="dv">5</span>)) == (<span class="kw">aref</span> x &#39;(<span class="dv">1</span> <span class="dv">5</span>) <span class="kw">t</span> <span class="kw">t</span>)</a>
<a class="sourceLine" id="cb2-2" title="2">(<span class="kw">aref</span> x <span class="dv">2</span> &#39;(<span class="dv">1</span> <span class="dv">5</span>)) == (<span class="kw">aref</span> x <span class="dv">2</span> &#39;(<span class="dv">1</span> <span class="dv">5</span>) <span class="kw">t</span>)</a></code></pre></div>
<ul>
<li>newaxis</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb3-1" title="1">(<span class="kw">aref</span> x &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">5</span>) <span class="kw">nil</span> <span class="dv">2</span> <span class="dv">3</span>)</a></code></pre></div>
<ul>
<li>ellipsis</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb4-1" title="1">(<span class="kw">aref</span> x &#39;- <span class="dv">2</span>) <span class="op">=</span> (<span class="kw">aref</span> x <span class="kw">t</span> <span class="kw">t</span> <span class="dv">2</span>) <span class="op">=</span> x[...,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb4-2" title="2">(<span class="kw">aref</span> x <span class="dv">2</span> &#39;-) <span class="op">=</span> (<span class="kw">aref</span> x <span class="dv">2</span> <span class="kw">t</span> <span class="kw">t</span>) <span class="op">=</span> x[<span class="dv">2</span>,...]</a>
<a class="sourceLine" id="cb4-3" title="3">(<span class="kw">aref</span> x <span class="dv">2</span> &#39;- <span class="dv">3</span>) <span class="op">=</span> (<span class="kw">aref</span> x <span class="dv">2</span> <span class="kw">t</span> <span class="dv">3</span>) <span class="op">=</span> x[<span class="dv">2</span>,...,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb4-4" title="4">(<span class="kw">aref</span> x <span class="dv">2</span> <span class="dv">3</span> &#39;-) <span class="op">=</span> (<span class="kw">aref</span> x <span class="dv">2</span> <span class="dv">3</span> <span class="kw">t</span>) <span class="op">=</span> x[<span class="dv">2</span>,<span class="dv">3</span>,...]</a></code></pre></div>
</div></div></div><h2 id="src/2typeinfer.lisp"><span class="file">2typeinfer</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/2typeinfer.lisp">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defmethod---documentation-common-lisp-(x-symbol)-(type-(eql-'inferer))"><span class="doctype">defmethod</span><span class="sep1">:</span><span class="name" id="COMMON-LISP:DOCUMENTATION">documentation</span><span class="package">common-lisp</span><span class="args lisp">(x symbol) (type (eql 'inferer))</span></h3><div class="docstring missing">(documentation missing)</div></div></div><h2 id="src/3arange.lisp"><span class="file">3arange</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/3arange.lisp">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defun-,-define-compiler-macro---arange-numcl.exported-&rest-args"><span class="doctype">defun</span><span class="sep2">,</span><span class="doctype">define-compiler-macro</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:ARANGE">arange</span><span class="package">numcl.exported</span><span class="args lisp">&amp;rest args</span></h3></div><div class="entry"><h3 id="defun---linspace-numcl.exported-start-stop-length-&key-type-endpoint"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:LINSPACE">linspace</span><span class="package">numcl.exported</span><span class="args lisp">start stop length &amp;key type endpoint</span></h3><div class="docstring missing">(all documentation missing)</div></div></div><h2 id="src/3array.lisp"><span class="file">3array</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/3array.lisp">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defun---asarray-numcl.exported-contents-&key-type"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:ASARRAY">asarray</span><span class="package">numcl.exported</span><span class="args lisp">contents &amp;key type</span></h3><div class="docstring"><p>Copy CONTENTS to a new array. When CONTENTS is a multidimentional array, its elements are copied to a new array that guarantees the NUMCL assumption. When CONTENTS is a nested sequence, it is traversed up to the depth that guarantees the sane shape for an array. When elements are copied, it is coerced to TYPE. When TYPE is not given, it is replaced with the float-contagion type deduced from the elements of CONTENTS. It may return a 0-dimensional array with CONTENTS being the only element.</p>
<p>For example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb1-1" title="1"><span class="co">;; a vector of two lists.</span></a>
<a class="sourceLine" id="cb1-2" title="2">(asarray &#39;((<span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">2</span>)))               -&gt; #((<span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">2</span>))</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">;; a 2D array of 4 lists.</span></a>
<a class="sourceLine" id="cb1-4" title="4">(asarray &#39;(((<span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">2</span>)) ((<span class="dv">3</span>) (<span class="dv">3</span> <span class="dv">4</span>)))) -&gt; #2A(((<span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">2</span>)) ((<span class="dv">3</span>) (<span class="dv">3</span> <span class="dv">4</span>)))</a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6">(asarray &#39;((<span class="dv">1</span> <span class="dv">2</span>) (<span class="dv">3</span> <span class="dv">4</span>)))    -&gt; #2A((<span class="dv">1</span> <span class="dv">2</span>) (<span class="dv">3</span> <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb1-7" title="7">(asarray #(#(<span class="dv">1</span> <span class="dv">2</span>) #(<span class="dv">3</span> <span class="dv">4</span>)))  -&gt; #2A((<span class="dv">1</span> <span class="dv">2</span>) (<span class="dv">3</span> <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb1-8" title="8">(asarray #((<span class="dv">1</span> <span class="dv">2</span>) (<span class="dv">3</span> <span class="dv">4</span>)))    -&gt; #2A((<span class="dv">1</span> <span class="dv">2</span>) (<span class="dv">3</span> <span class="dv">4</span>))</a></code></pre></div>
<p>However, this behavior may not be ideal because the resulting shape could be affected by the lengths of the strings.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb2-1" title="1">(asarray #(#(<span class="dv">1</span> <span class="dv">2</span>) #(<span class="dv">3</span> <span class="dv">4</span>)))   -&gt; #2A((<span class="dv">1</span> <span class="dv">2</span>) (<span class="dv">3</span> <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb2-2" title="2">(asarray #(#(<span class="dv">1</span> <span class="dv">2</span>) #(<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>))) -&gt; #(#(<span class="dv">1</span> <span class="dv">2</span>) #(<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>))</a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4">(asarray #(<span class="st">&quot;aa&quot;</span> <span class="st">&quot;aa&quot;</span>))   -&gt; #2A((#a #a) (#a #a))</a>
<a class="sourceLine" id="cb2-5" title="5">(asarray #(<span class="st">&quot;aa&quot;</span> <span class="st">&quot;aaa&quot;</span>))  -&gt; #(<span class="st">&quot;aa&quot;</span> <span class="st">&quot;aaa&quot;</span>)</a></code></pre></div>
<p>As a remedy to this problem, we allow TYPE to be a specifier for vector subtypes. Providing such a type specifier will keep the leaf objects (e.g. strings) from split into individual elements. We don't allow it to be a multidimentional array [at the moment.]</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb3-1" title="1">(asarray #(#(<span class="dv">1</span> <span class="dv">2</span>) #(<span class="dv">3</span> <span class="dv">4</span>))   <span class="bu">:type</span> &#39;(<span class="kw">array</span> <span class="kw">fixnum</span> (<span class="op">*</span>))) -&gt; #(#(<span class="dv">1</span> <span class="dv">2</span>) #(<span class="dv">3</span> <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb3-2" title="2">(asarray #(#(<span class="dv">1</span> <span class="dv">2</span>) #(<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)) <span class="bu">:type</span> &#39;(<span class="kw">array</span> <span class="kw">fixnum</span> (<span class="op">*</span>))) -&gt; #(#(<span class="dv">1</span> <span class="dv">2</span>) #(<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>))</a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4">(asarray #(<span class="st">&quot;aa&quot;</span> <span class="st">&quot;aa&quot;</span>)  <span class="bu">:type</span> &#39;string)    -&gt; #(<span class="st">&quot;aa&quot;</span> <span class="st">&quot;aa&quot;</span>)</a>
<a class="sourceLine" id="cb3-5" title="5">(asarray #(<span class="st">&quot;aa&quot;</span> <span class="st">&quot;aaa&quot;</span>) <span class="bu">:type</span> &#39;string)    -&gt; #(<span class="st">&quot;aa&quot;</span> <span class="st">&quot;aaa&quot;</span>)</a>
<a class="sourceLine" id="cb3-6" title="6"></a>
<a class="sourceLine" id="cb3-7" title="7">(asarray &#39;((<span class="dv">1</span> <span class="dv">2</span>) (<span class="dv">3</span> <span class="dv">4</span>))   <span class="bu">:type</span> &#39;(<span class="kw">array</span> <span class="kw">fixnum</span> (<span class="op">*</span> <span class="op">*</span>)))  -&gt; <span class="kw">error</span></a></code></pre></div>
</div></div></div><h2 id="src/3copy.lisp"><span class="file">3copy</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/3copy.lisp">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defun---copy-numcl.exported-array"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:COPY">copy</span><span class="package">numcl.exported</span><span class="args lisp">array</span></h3></div><div class="entry"><h3 id="defun---astype-numcl.exported-array-type"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:ASTYPE">astype</span><span class="package">numcl.exported</span><span class="args lisp">array type</span></h3><div class="docstring missing">(all documentation missing)</div></div></div><h2 id="src/3zeros.lisp"><span class="file">3zeros</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/3zeros.lisp">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defun---empty-numcl.exported-shape-&key-(type-'bit)"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:EMPTY">empty</span><span class="package">numcl.exported</span><span class="args lisp">shape &amp;key (type 'bit)</span></h3></div><div class="entry"><h3 id="defun---full-numcl.exported-shape-value-&key-(type-(type-of-value))"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:FULL">full</span><span class="package">numcl.exported</span><span class="args lisp">shape value &amp;key (type (type-of value))</span></h3></div><div class="entry"><h3 id="defun---zeros-,-ones-numcl.exported-shape-&key-(type-'bit)"><span class="doctype">defun</span><span class="sep1">:</span><span class="name defun" id="NUMCL.EXPORTED:ZEROS">zeros</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:ONES">ones</span><span class="package">numcl.exported</span><span class="args lisp">shape &amp;key (type 'bit)</span></h3></div><div class="entry"><h3 id="defun---empty-like-numcl.exported-array-&key-(type-(array-element-type-array))"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:EMPTY-LIKE">empty-like</span><span class="package">numcl.exported</span><span class="args lisp">array &amp;key (type (array-element-type array))</span></h3></div><div class="entry"><h3 id="defun---full-like-numcl.exported-array-value-&key-(type-(array-element-type-array))"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:FULL-LIKE">full-like</span><span class="package">numcl.exported</span><span class="args lisp">array value &amp;key (type (array-element-type array))</span></h3></div><div class="entry"><h3 id="defun---zeros-like-,-ones-like-numcl.exported-array-&key-(type-(array-element-type-array))"><span class="doctype">defun</span><span class="sep1">:</span><span class="name defun" id="NUMCL.EXPORTED:ZEROS-LIKE">zeros-like</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:ONES-LIKE">ones-like</span><span class="package">numcl.exported</span><span class="args lisp">array &amp;key (type (array-element-type array))</span></h3><div class="docstring"><p>Equivalent of the same function in numpy. Note the default <code>type</code> difference.</p>
<ul>
<li><code>empty</code> : does not explicitly fill the array. In an unsafe compiler setting, junk value may appear.</li>
<li><code>full</code> : fill the array with a certain value.</li>
<li><code>zeros</code>, <code>ones</code> : fill the array with zeros / ones. <code>type</code> affects the actual value being filled.</li>
<li><code>X-like</code> : similar to above functions, but takes another array and returns the array of the same shape.</li>
</ul>
</div></div></div><h2 id="src/4concatenate.lisp"><span class="file">4concatenate</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/4concatenate.lisp">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defun---concatenate-,-stack-numcl.exported-arrays-&key-(axis-0)-out"><span class="doctype">defun</span><span class="sep1">:</span><span class="name defun" id="NUMCL.EXPORTED:CONCATENATE">concatenate</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:STACK">stack</span><span class="package">numcl.exported</span><span class="args lisp">arrays &amp;key (axis 0) out</span></h3><div class="docstring missing">(documentation missing)</div></div></div><h2 id="src/4split.lisp"><span class="file">4split</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/4split.lisp">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defun---unstack-numcl.exported-array-&key-(axis-0)"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:UNSTACK">unstack</span><span class="package">numcl.exported</span><span class="args lisp">array &amp;key (axis 0)</span></h3><div class="docstring missing">(documentation missing)</div></div></div><h2 id="src/5numeric.lisp"><span class="file">5numeric</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/5numeric.lisp">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defun---map-into-numcl.exported-result-sequence-function-&rest-sequences"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:MAP-INTO">map-into</span><span class="package">numcl.exported</span><span class="args lisp">result-sequence function &amp;rest sequences</span></h3></div><div class="entry"><h3 id="defun---map-numcl.exported-result-type-function-&rest-sequences"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:MAP">map</span><span class="package">numcl.exported</span><span class="args lisp">result-type function &amp;rest sequences</span></h3></div><div class="entry"><h3 id="defun---map-array-into-numcl.exported-result-sequence-function-&rest-sequences"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:MAP-ARRAY-INTO">map-array-into</span><span class="package">numcl.exported</span><span class="args lisp">result-sequence function &amp;rest sequences</span></h3></div><div class="entry"><h3 id="defun---map-array-numcl.exported-function-&rest-sequences"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:MAP-ARRAY">map-array</span><span class="package">numcl.exported</span><span class="args lisp">function &amp;rest sequences</span></h3><div class="docstring missing">(all documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---broadcast-numcl.exported-fn-x-y-&key-type-(atomic-(fdefinition-fn))"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:BROADCAST">broadcast</span><span class="package">numcl.exported</span><span class="args lisp">fn x y &amp;key type (atomic (fdefinition fn))</span></h3><div class="docstring"><p>For binary functions</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---sin-,-cos-,-tan-,-asin-,-acos-,-atan-,-sinh-,-cosh-,-tanh-,-exp-,-log-,-sqrt-,-abs-,-signum-,-cis-,-conjugate-,-phase-,-realpart-,-imagpart-,-numerator-,-denominator-,-logcount-,-integer-length-,-square-numcl.exported-x"><span class="doctype">defun</span><span class="sep1">:</span><span class="name defun" id="NUMCL.EXPORTED:SIN">sin</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:COS">cos</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:TAN">tan</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:ASIN">asin</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:ACOS">acos</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:ATAN">atan</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:SINH">sinh</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:COSH">cosh</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:TANH">tanh</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:EXP">exp</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:LOG">log</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:SQRT">sqrt</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:ABS">abs</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:SIGNUM">signum</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:CIS">cis</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:CONJUGATE">conjugate</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:PHASE">phase</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:REALPART">realpart</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:IMAGPART">imagpart</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:NUMERATOR">numerator</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:DENOMINATOR">denominator</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:LOGCOUNT">logcount</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:INTEGER-LENGTH">integer-length</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:SQUARE">square</span><span class="package">numcl.exported</span><span class="args lisp">x</span></h3></div><div class="entry"><h3 id="defun---1+-,-1--numcl.exported-array"><span class="doctype">defun</span><span class="sep1">:</span><span class="name defun" id="NUMCL.EXPORTED:1+">1+</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:1-">1-</span><span class="package">numcl.exported</span><span class="args lisp">array</span></h3></div><div class="entry"><h3 id="defun---+-,---,-*-,---,-max-,-min-numcl.exported-&rest-args"><span class="doctype">defun</span><span class="sep1">:</span><span class="name defun" id="NUMCL.EXPORTED:+">+</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:-">-</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:*">*</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:/">/</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:MAX">max</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:MIN">min</span><span class="package">numcl.exported</span><span class="args lisp">&amp;rest args</span></h3></div><div class="entry"><h3 id="defun---clip-numcl.exported-array-min-max"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:CLIP">clip</span><span class="package">numcl.exported</span><span class="args lisp">array min max</span></h3></div><div class="entry"><h3 id="define-symbol-macro---+-,-++-,-+++-,-*-,-**-,-***-,---,----,-----numcl.exported"><span class="doctype">define-symbol-macro</span><span class="sep1">:</span><span class="name define-symbol-macro" id="NUMCL.EXPORTED:+">+</span><span class="sep2">,</span><span class="name define-symbol-macro" id="NUMCL.EXPORTED:++">++</span><span class="sep2">,</span><span class="name define-symbol-macro" id="NUMCL.EXPORTED:+++">+++</span><span class="sep2">,</span><span class="name define-symbol-macro" id="NUMCL.EXPORTED:*">*</span><span class="sep2">,</span><span class="name define-symbol-macro" id="NUMCL.EXPORTED:**">**</span><span class="sep2">,</span><span class="name define-symbol-macro" id="NUMCL.EXPORTED:***">***</span><span class="sep2">,</span><span class="name define-symbol-macro" id="NUMCL.EXPORTED:/">/</span><span class="sep2">,</span><span class="name define-symbol-macro" id="NUMCL.EXPORTED://">//</span><span class="sep2">,</span><span class="name define-symbol-macro" id="NUMCL.EXPORTED:///">///</span><span class="package">numcl.exported</span></h3></div><div class="entry"><h3 id="defun---mod-,-rem-,-round-,-floor-,-ceiling-,-truncate-,-fround-,-ffloor-,-fceiling-,-ftruncate-numcl.exported-number-&optional-(divisor-1)"><span class="doctype">defun</span><span class="sep1">:</span><span class="name defun" id="NUMCL.EXPORTED:MOD">mod</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:REM">rem</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:ROUND">round</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:FLOOR">floor</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:CEILING">ceiling</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:TRUNCATE">truncate</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:FROUND">fround</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:FFLOOR">ffloor</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:FCEILING">fceiling</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:FTRUNCATE">ftruncate</span><span class="package">numcl.exported</span><span class="args lisp">number &amp;optional (divisor 1)</span></h3></div><div class="entry"><h3 id="defun---=-,--=-,-<=-,->=-,-<-,->-numcl.exported-x-y"><span class="doctype">defun</span><span class="sep1">:</span><span class="name defun" id="NUMCL.EXPORTED:=">=</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:/=">/=</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:<=">&lt;=</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:>=">&gt;=</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:<">&lt;</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:>">&gt;</span><span class="package">numcl.exported</span><span class="args lisp">x y</span></h3></div><div class="entry"><h3 id="defpattern---=-,--=-,-<=-,->=-,-<-,->-numcl.exported-x"><span class="doctype">defpattern</span><span class="sep1">:</span><span class="name defpattern" id="NUMCL.EXPORTED:=">=</span><span class="sep2">,</span><span class="name defpattern" id="NUMCL.EXPORTED:/=">/=</span><span class="sep2">,</span><span class="name defpattern" id="NUMCL.EXPORTED:<=">&lt;=</span><span class="sep2">,</span><span class="name defpattern" id="NUMCL.EXPORTED:>=">&gt;=</span><span class="sep2">,</span><span class="name defpattern" id="NUMCL.EXPORTED:<">&lt;</span><span class="sep2">,</span><span class="name defpattern" id="NUMCL.EXPORTED:>">&gt;</span><span class="package">numcl.exported</span><span class="args lisp">x</span></h3></div><div class="entry"><h3 id="defun---logand-,-logandc1-,-logandc2-,-logeqv-,-logior-,-lognand-,-lognor-,-logorc1-,-logorc2-,-logxor-numcl.exported-&rest-args"><span class="doctype">defun</span><span class="sep1">:</span><span class="name defun" id="NUMCL.EXPORTED:LOGAND">logand</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:LOGANDC1">logandc1</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:LOGANDC2">logandc2</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:LOGEQV">logeqv</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:LOGIOR">logior</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:LOGNAND">lognand</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:LOGNOR">lognor</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:LOGORC1">logorc1</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:LOGORC2">logorc2</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:LOGXOR">logxor</span><span class="package">numcl.exported</span><span class="args lisp">&amp;rest args</span></h3></div><div class="entry"><h3 id="defun---lognot-numcl.exported-x"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:LOGNOT">lognot</span><span class="package">numcl.exported</span><span class="args lisp">x</span></h3><div class="docstring missing">(all documentation missing)</div></div></div><h2 id="src/5random.lisp"><span class="file">5random</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/5random.lisp">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defun---shuffle-numcl.exported-array-or-sequence-&key-(start-0)-end"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:SHUFFLE">shuffle</span><span class="package">numcl.exported</span><span class="args lisp">array-or-sequence &amp;key (start 0) end</span></h3><div class="docstring"><p>This code extends alexandria:shuffle. It additionally accepts arrays and shuffles the elements according to the first axis, viewing the remaining axes as one "element".</p>
<p>Original documentation:</p>
<p>Returns a random permutation of SEQUENCE bounded by START and END. Original sequence may be destructively modified, and (if it contains CONS or lists themselv) share storage with the original one. Signals an error if SEQUENCE is not a proper sequence.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---bernoulli-numcl.exported-p-&optional-shape"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:BERNOULLI">bernoulli</span><span class="package">numcl.exported</span><span class="args lisp">p &amp;optional shape</span></h3><div class="docstring"><p>Returns a bit array whose elements are 1 with probability P</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---bernoulli-like-numcl.exported-a"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:BERNOULLI-LIKE">bernoulli-like</span><span class="package">numcl.exported</span><span class="args lisp">a</span></h3></div><div class="entry"><h3 id="defun---beta-numcl.exported-a-b-&optional-shape-(type-(union-to-float-type-(type-of-a)-(type-of-b)))"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:BETA">beta</span><span class="package">numcl.exported</span><span class="args lisp">a b &amp;optional shape (type (union-to-float-type (type-of a) (type-of b)))</span></h3></div><div class="entry"><h3 id="defun---binomial-numcl.exported-n-p-&optional-shape"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:BINOMIAL">binomial</span><span class="package">numcl.exported</span><span class="args lisp">n p &amp;optional shape</span></h3></div><div class="entry"><h3 id="defun---exponential-numcl.exported-scale-&optional-shape-(type-(union-to-float-type-(type-of-scale)))"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:EXPONENTIAL">exponential</span><span class="package">numcl.exported</span><span class="args lisp">scale &amp;optional shape (type (union-to-float-type (type-of scale)))</span></h3></div><div class="entry"><h3 id="defun---f-numcl.exported-dfnum-dfden-&optional-shape-(type-(union-to-float-type-(type-of-dfnum)-(type-of-dfden)))"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:F">f</span><span class="package">numcl.exported</span><span class="args lisp">dfnum dfden &amp;optional shape (type (union-to-float-type (type-of dfnum) (type-of dfden)))</span></h3></div><div class="entry"><h3 id="defun---gamma-numcl.exported-k-&optional-(theta-1.0)-shape-(type-(union-to-float-type-(type-of-k)-(type-of-theta)))"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:GAMMA">gamma</span><span class="package">numcl.exported</span><span class="args lisp">k &amp;optional (theta 1.0) shape (type (union-to-float-type (type-of k) (type-of theta)))</span></h3><div class="docstring missing">(all documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---multinomial-numcl.exported-n-pvals-&optional-shape"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:MULTINOMIAL">multinomial</span><span class="package">numcl.exported</span><span class="args lisp">n pvals &amp;optional shape</span></h3><div class="docstring"><p>pvals is a sequence of probabilities summing up to 1.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---negative-binomial-numcl.exported-n-p-&optional-shape"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:NEGATIVE-BINOMIAL">negative-binomial</span><span class="package">numcl.exported</span><span class="args lisp">n p &amp;optional shape</span></h3></div><div class="entry"><h3 id="defun---normal-numcl.exported-&optional-(mean-0.0)-(var-1.0)-shape-(type-(union-to-float-type-(type-of-mean)-(type-of-var)))"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:NORMAL">normal</span><span class="package">numcl.exported</span><span class="args lisp">&amp;optional (mean 0.0) (var 1.0) shape (type (union-to-float-type (type-of mean) (type-of var)))</span></h3></div><div class="entry"><h3 id="defun---poisson-numcl.exported-&optional-(lambda-1.0)-shape-(type-(union-to-float-type-(type-of-lambda)))"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:POISSON">poisson</span><span class="package">numcl.exported</span><span class="args lisp">&amp;optional (lambda 1.0) shape (type (union-to-float-type (type-of lambda)))</span></h3></div><div class="entry"><h3 id="defun---uniform-numcl.exported-&optional-(low-0.0)-(high-1.0)-shape-type"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:UNIFORM">uniform</span><span class="package">numcl.exported</span><span class="args lisp">&amp;optional (low 0.0) (high 1.0) shape type</span></h3><div class="docstring missing">(all documentation missing)</div></div></div><h2 id="src/5reduce.lisp"><span class="file">5reduce</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/5reduce.lisp">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defun---reduce-array-numcl.exported-fn-array-&key-axes-(type-(%reduce-array-result-type-array-fn))-(initial-element-(zero-value-type))"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:REDUCE-ARRAY">reduce-array</span><span class="package">numcl.exported</span><span class="args lisp">fn array &amp;key axes (type (%reduce-array-result-type array fn)) (initial-element (zero-value type))</span></h3></div><div class="entry"><h3 id="defun---sum-,-prod-,-amax-,-amin-numcl.exported-array-&rest-args-&key-axes-type"><span class="doctype">defun</span><span class="sep1">:</span><span class="name defun" id="NUMCL.EXPORTED:SUM">sum</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:PROD">prod</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:AMAX">amax</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:AMIN">amin</span><span class="package">numcl.exported</span><span class="args lisp">array &amp;rest args &amp;key axes type</span></h3></div><div class="entry"><h3 id="defun---mean-,-variance-,-standard-deviation-,-avg-,-var-,-stdev-numcl.exported-array-&key-axes"><span class="doctype">defun</span><span class="sep1">:</span><span class="name defun" id="NUMCL.EXPORTED:MEAN">mean</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:VARIANCE">variance</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:STANDARD-DEVIATION">standard-deviation</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:AVG">avg</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:VAR">var</span><span class="sep2">,</span><span class="name defun" id="NUMCL.EXPORTED:STDEV">stdev</span><span class="package">numcl.exported</span><span class="args lisp">array &amp;key axes</span></h3><div class="docstring missing">(all documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---histogram-numcl.exported-array-&key-(low-(amin-array))-(high-(amax-array))-(split-1)"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:HISTOGRAM">histogram</span><span class="package">numcl.exported</span><span class="args lisp">array &amp;key (low (amin array)) (high (amax array)) (split 1)</span></h3><div class="docstring"><p>Returns a fixnum vector representing a histogram of values. The interval between LOW and HIGH are split by STEP value. All values less than LOW are put in the 0-th bucket; All values greater than equal to HIGH are put in the last bucket.</p>
</div></div></div><h2 id="src/5where.lisp"><span class="file">5where</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/5where.lisp">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defun---array-index-from-row-major-index-numcl.exported-array-row-major-index"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:ARRAY-INDEX-FROM-ROW-MAJOR-INDEX">array-index-from-row-major-index</span><span class="package">numcl.exported</span><span class="args lisp">array row-major-index</span></h3><div class="docstring"><p>Takes a multidimentional array and a row-major-index. Returns a list containing the normal index.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---argwhere-numcl.exported-array-fn"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:ARGWHERE">argwhere</span><span class="package">numcl.exported</span><span class="args lisp">array fn</span></h3><div class="docstring"><p>Returns a list of the multidimentional indices of the elements which satisfies the predicate FN. Note that the list elements are the multidimentional indices, even for a single-dimensional array.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---where-numcl.exported-array-fn"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:WHERE">where</span><span class="package">numcl.exported</span><span class="args lisp">array fn</span></h3><div class="docstring"><p>Returns a list of list of indices of the elements which satisfies the predicate FN. The first list contains the indices for the 1st dimension, the second list contains the indices for the 2nd dimension, and so on.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---nonzero-numcl.exported-array"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:NONZERO">nonzero</span><span class="package">numcl.exported</span><span class="args lisp">array</span></h3><div class="docstring"><p>collect multidimentional indices where the element is nonzero</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun---take-numcl.exported-array-indices"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:TAKE">take</span><span class="package">numcl.exported</span><span class="args lisp">array indices</span></h3><div class="docstring"><p>Collect the elements using a list of multidimentional indices (in a format returned by WHERE).</p>
</div></div></div><h2 id="src/6linear-algebra.lisp"><span class="file">6linear-algebra</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/6linear-algebra.lisp">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defun---einsum-numcl.exported-subscripts-&rest-args"><span class="doctype">defun</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:EINSUM">einsum</span><span class="package">numcl.exported</span><span class="args lisp">subscripts &amp;rest args</span></h3><div class="docstring"><p>Performs Einstein's summation. The SUBSCRIPT specification is significantly extended from that of Numpy and can be seens as a full-brown DSL for array operations.</p>
<p>SUBSCRIPTS is a sequence of the form <code>(&lt;SPEC&gt;+ [-&gt; &lt;TRANSFORM&gt;*] [-&gt; [&lt;SPEC&gt;*])</code>. The remaining arguments ARGS contain the input arrays and optionally the output arrays.</p>
<h1 id="spec">SPEC</h1>
<p>The first set of SPECs specifies the input subscripts, and the second set of SPECs specifies the output subscripts. Unlike Numpy, there can be multiple output subscripts: It can performs multiple operations in the same loop, then return multiple values. The symbol <code>-&gt;</code> can be a string and can belong to any package because it is compared by STRING=.</p>
<p>Each SPEC is an alphabetical string designator, such as a symbol IJK or a string "IJK", where each alphabet is considered as an index. It signals a type-error when it contains any non-alpha char. Note that a symbol NIL is interpreted as an empty list rather than N, I and L.</p>
<p>Alternatively, each SPEC can be a list that contains a list of symbols. For example, <code>((i j) (j k) -&gt; (i k))</code> and <code>(ij jk -&gt; ik)</code> are equivalent.</p>
<p>When -&gt; and the output SPECs are omitted, a single output is assumed and its spec is a union of the input specs. For example, <code>(ij jk)</code> is equivalent to <code>(ij jk -&gt; ijk)</code>. Note that <code>(ij jk)</code> and <code>(ij jk -&gt;)</code> have the different meanings: The latter sums up all elements.</p>
<h1 id="transform">TRANSFORM</h1>
<p>TRANSFORM is a list of element-wise operations. The number of TRANSFORM should correspond to the number of outputs. In each TRANSFORM, the elements in the input arrays can be referenced by $N, where N is a 1-indexed number. Similarly the output array can be referred to by @N.</p>
<p>For example, <code>(ij ik -&gt; (+ @1 (* $1 $2)) -&gt; ik)</code> is equivalent to <code>(ij ik -&gt; ik)</code> (a GEMM).</p>
<p>By default, TRANSFORM is <code>(+ @1 (* $1 ... $N))</code> for N inputs, which is equivalent to Einstein's summation.</p>
<h1 id="args">ARGS</h1>
<p>The shape of each input array should unify against the corresponding input spec. For example, with a spec IJI, the input array should be of rank 3 as well as the 1st and the 3rd dimension of the input array should be the same.</p>
<p>The shape of each output array is determined by the corresponding output spec. For example, if SUBSCRIPTS is <code>(ij jk -&gt; ik)</code>, the output is an array of rank 2, and the output shape has the same dimension as the first input in the first axis, and the same dimension as the second input in the second axis.</p>
<p>If the output arrays are provided, their shapes and types are also checked against the corresponding output spec. The types should match the result of the numerical operations on the elements of the input arrays.</p>
<p>The outputs are calculated in the following rule.</p>
<ul>
<li><p>The output array types are calculated based on the TRANSFORM, and the shapes are calcurated based on the SPEC and the input arrays.</p></li>
<li><p>The output arrays are allocated and initialized by zeros.</p></li>
<li><p>Einsum nests one loop for each index in the input specs. For example, <code>(ij jk -&gt; ik)</code> results in a triple loop.</p></li>
<li><p>In the innermost loop, each array element is bound to <code>$1..$N</code> / <code>@1..@N</code>.</p></li>
<li><p>For each <code>@i</code>, <code>i</code>-th TRANSFORM is evaluated and assigned to <code>@i</code>.</p></li>
<li><p>If the same index appears multiple times in a single spec, they share the same value in each iteration. For example, <code>(ii -&gt; i)</code> returns the diagonal elements of the matrix.</p></li>
</ul>
<p>When TRANSFORMs are missing, it follows naturally from the default TRANSFORM values that</p>
<ul>
<li>When an index used in the input spec is missing in the output spec, the axis is aggregated over the iteration by summation.</li>
<li>If the same index appears across the different input specs, the element values from the multiple input arrays are aggregated by multiplication. For example, <code>(ij jk -&gt; ik)</code> will perform <code>(setf (aref a2 i k) (* (aref a0 i j) (aref a1 j k)))</code> when a0, a1 are the input arrays and a2 is the output array.</li>
</ul>
<p>For example, (einsum '(ij jk) a b) is equivalent to:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb1-1" title="1"> (<span class="kw">dotimes</span> (i &lt;max&gt; &lt;output&gt;)</a>
<a class="sourceLine" id="cb1-2" title="2">   (<span class="kw">dotimes</span> (j &lt;max&gt;)</a>
<a class="sourceLine" id="cb1-3" title="3">     (<span class="kw">dotimes</span> (k &lt;max&gt;)</a>
<a class="sourceLine" id="cb1-4" title="4">       (<span class="kw">setf</span> (<span class="kw">aref</span> &lt;output&gt; i j k) (<span class="op">*</span> (<span class="kw">aref</span> a i j) (<span class="kw">aref</span> b j k))))))</a></code></pre></div>
<h1 id="performance">Performance</h1>
<p>If SUBSCRIPTS is a constant, the compiler macro builds an iterator function and make them inlined. Otherwise, a new function is made in each call to einsum, resulting in a large bottleneck. (It could be memoized in the future.)</p>
<p>The nesting order of the loops are automatically decided based on the specs. The order affects the memory access pattern and therefore the performance due to the access locality. For example, when writing a GEMM which accesses three matrices by <code>(setf (aref output i j) (* (aref a i k) (aref b k j)))</code>, it is well known that ikj-loop is the fastest among other loops, e.g. ijk-loop. EINSUM reorders the indices so that it maximizes the cache locality.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-compiler-macro---einsum-numcl.exported-subscripts-&rest-args"><span class="doctype">define-compiler-macro</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:EINSUM">einsum</span><span class="package">numcl.exported</span><span class="args lisp">subscripts &amp;rest args</span></h3><div class="docstring missing">(documentation missing)</div></div></div><h2 id="src/8linear-algebra2.lisp"><span class="file">8linear-algebra2</span><span class="extension">lisp</span><a class="source-link" href="https://github.com/numcl/numcl/blob/master/src/8linear-algebra2.lisp">[edit on web]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defun-,-define-compiler-macro---transpose-numcl.exported-matrix-&optional-result"><span class="doctype">defun</span><span class="sep2">,</span><span class="doctype">define-compiler-macro</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:TRANSPOSE">transpose</span><span class="package">numcl.exported</span><span class="args lisp">matrix &amp;optional result</span></h3><div class="docstring"><p>Reverses the axes of an array.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-,-define-compiler-macro---matmul-numcl.exported-a-b-&optional-result"><span class="doctype">defun</span><span class="sep2">,</span><span class="doctype">define-compiler-macro</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:MATMUL">matmul</span><span class="package">numcl.exported</span><span class="args lisp">a b &amp;optional result</span></h3><div class="docstring"><p>Matrix product of two arrays.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-,-define-compiler-macro---vdot-numcl.exported-a-b-&optional-result"><span class="doctype">defun</span><span class="sep2">,</span><span class="doctype">define-compiler-macro</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:VDOT">vdot</span><span class="package">numcl.exported</span><span class="args lisp">a b &amp;optional result</span></h3><div class="docstring"><p>Dot product of two vectors. For complex values, the first value is conjugated.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-,-define-compiler-macro---inner-numcl.exported-a-b-&optional-result"><span class="doctype">defun</span><span class="sep2">,</span><span class="doctype">define-compiler-macro</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:INNER">inner</span><span class="package">numcl.exported</span><span class="args lisp">a b &amp;optional result</span></h3><div class="docstring"><p>Inner product of two vectors.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-,-define-compiler-macro---outer-numcl.exported-a-b-&optional-result"><span class="doctype">defun</span><span class="sep2">,</span><span class="doctype">define-compiler-macro</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:OUTER">outer</span><span class="package">numcl.exported</span><span class="args lisp">a b &amp;optional result</span></h3><div class="docstring"><p>Compute the outer product of two vectors.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-,-define-compiler-macro---kron-numcl.exported-a-b-&optional-result"><span class="doctype">defun</span><span class="sep2">,</span><span class="doctype">define-compiler-macro</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:KRON">kron</span><span class="package">numcl.exported</span><span class="args lisp">a b &amp;optional result</span></h3><div class="docstring"><p>Compute the kronecker product of two vectors.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-,-define-compiler-macro---diag-numcl.exported-a-&optional-result"><span class="doctype">defun</span><span class="sep2">,</span><span class="doctype">define-compiler-macro</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:DIAG">diag</span><span class="package">numcl.exported</span><span class="args lisp">a &amp;optional result</span></h3><div class="docstring"><p>Return the diagonal element of a matrix as a vector</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-,-define-compiler-macro---tri-numcl.exported-n-&key-(m-n)-(k-0)-(type-'bit)"><span class="doctype">defun</span><span class="sep2">,</span><span class="doctype">define-compiler-macro</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:TRI">tri</span><span class="package">numcl.exported</span><span class="args lisp">n &amp;key (m n) (k 0) (type 'bit)</span></h3><div class="docstring"><p>Returns a triangle matrix whose lower diagnonal (including the diagonal) filled with 1. N,M specifies the shape of the return array. K will adjust the sub-diagonal -- positive K fills more 1s.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-,-define-compiler-macro---tril-numcl.exported-matrix-&optional-(k-0)"><span class="doctype">defun</span><span class="sep2">,</span><span class="doctype">define-compiler-macro</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:TRIL">tril</span><span class="package">numcl.exported</span><span class="args lisp">matrix &amp;optional (k 0)</span></h3><div class="docstring"><p>Returns the copy of matrix with elements above the k-th diagonal zeroed. Positive K fills less 0s.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-,-define-compiler-macro---triu-numcl.exported-matrix-&optional-(k-0)"><span class="doctype">defun</span><span class="sep2">,</span><span class="doctype">define-compiler-macro</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:TRIU">triu</span><span class="package">numcl.exported</span><span class="args lisp">matrix &amp;optional (k 0)</span></h3><div class="docstring"><p>Returns the copy of matrix with elements below the k-th diagonal zeroed. Positive K fills more 0s.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-,-define-compiler-macro---eye-numcl.exported-n-&key-(m-n)-(k-0)-(type-'bit)"><span class="doctype">defun</span><span class="sep2">,</span><span class="doctype">define-compiler-macro</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:EYE">eye</span><span class="package">numcl.exported</span><span class="args lisp">n &amp;key (m n) (k 0) (type 'bit)</span></h3><div class="docstring"><p>Returns a matrix whose k-th diagnonal filled with 1. N,M specifies the shape of the return array. K will adjust the sub-diagonal -- positive K moves it upward.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-,-define-compiler-macro---vander-numcl.exported-v-&key-(n-(length-v))-increasing"><span class="doctype">defun</span><span class="sep2">,</span><span class="doctype">define-compiler-macro</span><span class="sep1">:</span><span class="name" id="NUMCL.EXPORTED:VANDER">vander</span><span class="package">numcl.exported</span><span class="args lisp">v &amp;key (n (length v)) increasing</span></h3><div class="docstring"><p>Returns a matrix where M[i,j] == V[i]^(N-j) when increasing is false (default), and M[i,j] == V[i]^j when increasing is true.</p>
</div></div></div></div><div class="footer"></div></body></html>